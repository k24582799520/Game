<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>æƒ…è¶£å¤§å¯Œç¿</title>
<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<style>
  :root{--bg:#faf9f7;--card:#ffffff;--accent:#5b8cff;--muted:#666;--dice-size:96px;}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans TC",sans-serif;background:var(--bg);color:#111}
  .wrap{max-width:900px;margin:0 auto;padding:16px;display:flex;flex-direction:column;gap:12px}
  header{display:flex;align-items:center;gap:12px}
  h1{font-size:18px;margin:0}
  .card{background:var(--card);border-radius:12px;padding:12px;box-shadow:0 6px 20px rgba(12,15,30,0.06); position:relative;}
  .row{display:flex;gap:8px;align-items:center}
  input[type=text]{flex:1;padding:10px;border-radius:8px;border:1px solid #eee}
  button{background:var(--accent);color:white;border:none;padding:10px 12px;border-radius:8px;font-weight:600}
  /* board: æ¯è¡Œ 5 æ ¼ï¼Œæ ¼å­ä¿æŒæ­£æ–¹å½¢ (responsive) */
  .board{
    display:grid;
    grid-template-columns:repeat(5,1fr);
    gap:6px;
    padding:8px;
    touch-action:manipulation;
    align-items:stretch;
  }
  /* æ¯å€‹æ ¼å­ç¶­æŒæ­£æ–¹å½¢ï¼›æ–‡å­—èˆ‡åœ–ç¤ºç½®ä¸­ */
  .cell{
    background:#f6f7fb;
    border-radius:8px;
    aspect-ratio:1/1;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    font-weight:600;
    color:#333;
    overflow:visible;
    z-index:1;
    padding:6px;
    box-sizing:border-box;
  }
  /* ç¬¬ä¸€æ ¼ï¼ˆèµ·é»ï¼‰èƒŒæ™¯è‰² */
  .cell[data-idx="0"]{
    background:#FFFD73;
  }
  /* æœ€å¾Œä¸€æ ¼ï¼ˆçµ‚é»ï¼‰èƒŒæ™¯è‰² */
  .cell[data-idx="49"]{
    background:#7AFF95;
  }
  .cell .idx{ display:none; }
  .pieces{
    display:flex;
    flex-wrap:wrap;
    gap:3px;
    justify-content:center;
    align-items:center;
    width:100%;
    max-width:64px;
    margin:auto;
    position:relative;
    z-index:10; /* æé«˜æ£‹å­å®¹å™¨å±¤ç´šï¼Œè“‹é cellLabel */
  }
  /* ç•¶æœ‰ 2+ å€‹æ£‹å­æ™‚æ”¹ç‚º grid 2x2 æ’åˆ— */
  .pieces:has(.piece:nth-child(2)){
    display:grid;
    grid-template-columns:repeat(2,1fr);
  }
  .piece{
    width:28px;
    height:28px;
    border-radius:50%;
    display:flex;
    align-items:center;
    justify-content:center;
    color:white;
    font-weight:700;
    font-size:13px;
    box-sizing:border-box;
    position:relative;
    z-index:11; /* ç¢ºä¿æ¯å€‹æ£‹å­ä¹Ÿåœ¨æ–‡å­—ä¸Šæ–¹ */
  }
  /* ç•¶æœ‰ 3+ å€‹æ£‹å­æ™‚ï¼Œç¸®å°ä¸¦ç¢ºä¿ 2x2 æ’åˆ— */
  .pieces:has(.piece:nth-child(3)) .piece{
    width:24px;
    height:24px;
    font-size:11px;
  }
  .pieces:has(.piece:nth-child(5)) .piece{
    width:20px;
    height:20px;
    font-size:10px;
  }
  .controls{display:flex;gap:8px;align-items:center;justify-content:center;margin-top:8px}
  .log{font-size:13px;color:var(--muted);padding:8px;border-radius:8px}
  .players{display:flex;gap:8px;overflow:auto;padding:6px}
  .playerCard{background:#f2f5ff;padding:8px;border-radius:8px;min-width:100px}
  .small{font-size:12px;color:var(--muted)}

  /* Room & turn display styling */
  .roomHead { font-size:14px; color:var(--muted); }
  .roomId { font-weight:800; font-size:18px; color:#111; padding:2px 6px; background:transparent; border-radius:6px; }
  .turnInfo { font-weight:700; font-size:16px; color:var(--accent); padding:4px 8px; border-radius:6px; background:rgba(91,140,255,0.06); }

  .rematchBtn{
    position:absolute;
    right:12px;
    bottom:12px;
    z-index:20;
    background:#10b981;
    border-radius:8px;
    padding:8px 12px;
    color:white;
    font-weight:700;
    box-shadow:0 6px 18px rgba(16,185,129,0.18);
    border:none;
  }

  /* 3D Dice styles */
  #diceOverlay{
    display:none;
    position:absolute;
    inset:0;
    background:rgba(0,0,0,0.12);
    align-items:center;
    justify-content:center;
    z-index:40;
    pointer-events:none;
  }
  #diceOverlay.show{ display:flex; pointer-events:auto; }
  .scene{ width:var(--dice-size); height:var(--dice-size); perspective:800px; }
  .cube{
    width:100%; height:100%;
    position:relative;
    transform-style:preserve-3d;
    transition: transform 0.7s cubic-bezier(.2,.8,.25,1);
  }
  .cube.rolling{ animation:spin 0.12s linear infinite; }
  @keyframes spin{
    0%{ transform: rotateX(0deg) rotateY(0deg) }
    100%{ transform: rotateX(360deg) rotateY(360deg) }
  }
  .face{
    position:absolute; width:100%; height:100%;
    display:flex; align-items:center; justify-content:center;
    backface-visibility:hidden;
    background:#fff; border-radius:10px; box-shadow:0 8px 24px rgba(2,6,23,0.12);
  }
  .face .pips{
    /* ç¸®å°æ•´å€‹é»é»ç¶²æ ¼æ¯”ä¾‹ï¼Œé¿å…è¶…å‡ºéª°å­é¢ */
    width:60%;
    height:60%;
    display:grid;
    grid-template-columns:repeat(3,1fr);
    grid-auto-rows:1fr;
    gap:4px;
    align-items:stretch;
    justify-items:stretch;
    margin:auto;
  }
  .face .pips .cell{
    display:flex;
    align-items:center;
    justify-content:center;
    width:100%;
    height:100%;
    min-height:0;      /* å–æ¶ˆå…¨åŸŸ .cell çš„ min-height å½±éŸ¿ */
    box-sizing:border-box;
    background: transparent; /* è®“å®ƒé€å‡º .face çš„ç™½è‰²èƒŒæ™¯ */
    border-radius:8px; /* å°åœ“è§’ï¼Œèˆ‡éª°é¢å‘¼æ‡‰ */
    padding:0;
  }
  .face .pips .dot{
    width:10px;
    height:10px;
    border-radius:50%;
    background:#111;
    display:block;
  }
  /* face positions */
  .face.f1{ transform: translateZ(calc(var(--dice-size)/2)); }
  .face.f6{ transform: rotateY(180deg) translateZ(calc(var(--dice-size)/2)); }
  .face.f3{ transform: rotateY(90deg) translateZ(calc(var(--dice-size)/2)); }
  .face.f4{ transform: rotateY(-90deg) translateZ(calc(var(--dice-size)/2)); }
  .face.f2{ transform: rotateX(90deg) translateZ(calc(var(--dice-size)/2)); }
  .face.f5{ transform: rotateX(-90deg) translateZ(calc(var(--dice-size)/2)); }

  @media (max-width:420px){
    .cell{min-height:48px}
    .piece{width:24px;height:24px;font-size:12px}
    :root{--dice-size:76px;}
  }

  /* pending modal (è¦†è“‹åœ¨ game card å…§) */
  .pendingModal{
    display:none;
    position:absolute;
    inset:0;
    align-items:center;
    justify-content:center;
    z-index:60;
    pointer-events:none;
  }
  .pendingModal.show{
    display:flex;
    pointer-events:auto;
  }
  .pendingBox{
    width: min(520px, 86%);
    background:#fff;
    border-radius:12px;
    padding:20px;
    box-shadow:0 18px 50px rgba(2,6,23,0.18);
    text-align:center;
  }
  .pendingLabel{
    font-size:20px;
    font-weight:800;
    color:#111;
    line-height:1.3;
    margin-bottom:18px;
    word-break:break-word;
  }
  .pendingActions{ display:flex; gap:12px; justify-content:center; }
  .pendingActions button{ padding:10px 14px; border-radius:8px; border:none; font-weight:700 }
  .btn-cancel{ background:#9ca3af; color:#fff }
  .btn-confirm{ background:#3b82f6; color:#fff }

  /* "è¼ªåˆ°ä½ äº†" modal */
  .yourTurnModal{
    display:none;
    position:fixed;
    inset:0;
    align-items:center;
    justify-content:center;
    z-index:70;
    background:rgba(0,0,0,0.5);
    pointer-events:none;
  }
  .yourTurnModal.show{
    display:flex;
    pointer-events:auto;
  }
  .yourTurnBox{
    width: min(280px, 85%);
    background:#fff;
    border-radius:16px;
    padding:24px 20px;
    box-shadow:0 20px 60px rgba(2,6,23,0.25);
    text-align:center;
  }
  .yourTurnTitle{
    font-size:20px;
    font-weight:800;
    color:#111;
    margin-bottom:16px;
  }
  .yourTurnBox button{
    width:100%;
    padding:12px;
    font-size:15px;
    font-weight:700;
    border-radius:10px;
    background:var(--accent);
    color:white;
    border:none;
    box-shadow:0 4px 12px rgba(59,130,246,0.3);
  }

  /* æ ¼å­æ¨™ç±¤ï¼ˆcellLabelï¼‰æ¨£å¼ï¼šå®Œå…¨ç½®ä¸­ã€å…è¨±æ›è¡Œä¸¦ä»¥ JS å‹•æ…‹èª¿æ•´å­—é«” */
  .cellLabel{
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    width:calc(100% - 16px);  /* ç•™å‡ºå·¦å³å„ 8px padding */
    text-align:center;
    font-size:14px;        /* åŸºæº–å­—é«”ï¼Œæœƒè¢« JS ç¸®æ”¾ */
    color:var(--muted);
    pointer-events:none;
    white-space:normal;
    overflow:hidden;
    display:block;
    line-height:1.1;
    z-index:5; /* æ–‡å­—å±¤ç´šä½æ–¼æ£‹å­ */
  }

  .dirArrow{
    position:absolute;
    width:20px;
    height:20px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:18px;
    color:var(--muted);
    pointer-events:none;
    line-height:1;
    z-index:50; /* æé«˜ï¼Œç¢ºä¿åœ¨å…¶ä»–æ ¼å­ä¹‹ä¸Š */
    transition:transform 180ms linear, opacity 180ms linear;
  }
  /* æ°´å¹³å‘å³ï¼ˆç®­é ­ç½®æ–¼æ ¼å­å³é‚Šç•Œï¼‰ */
  .dirArrow.dir-right{
    right:-10px;             /* adjust distance to border */
    top:50%;
    transform:translateY(-50%) rotate(0deg);
    opacity:0.95;
  }
  /* æ°´å¹³å‘å·¦ï¼ˆç®­é ­ç½®æ–¼æ ¼å­å·¦é‚Šç•Œï¼‰ */
  .dirArrow.dir-left{
    left:-10px;
    top:50%;
    transform:translateY(-50%) rotate(180deg);
    opacity:0.95;
  }
  /* å‚ç›´å‘ä¸‹ï¼ˆç®­é ­ç½®æ–¼æ ¼å­åº•éƒ¨é‚Šç•Œï¼‰ */
  .dirArrow.dir-down{
    bottom:-10px;
    left:50%;
    transform:translateX(-50%) rotate(90deg);
    opacity:0.95;
  }
  /* å‚ç›´å‘ä¸Šï¼ˆç®­é ­ç½®æ–¼æ ¼å­ä¸Šæ–¹é‚Šç•Œï¼‰ */
  .dirArrow.dir-up{
    top:-10px;
    left:50%;
    transform:translateX(-50%) rotate(-90deg);
    opacity:0.95;
  }
  .dirArrow.dir-none{
    opacity:0;
    pointer-events:none;
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>æƒ…è¶£å¤§å¯Œç¿</h1>
  </header>

  <div class="card" id="lobby">
    <div class="lobby-row" style="margin-bottom:8px; display:flex; flex-direction:column; gap:8px;">
      <input id="name" type="text" placeholder="è¼¸å…¥ä½ çš„æš±ç¨±" />
      <div class="lobby-actions" style="display:flex; gap:8px;">
        <button id="createBtn" style="flex:1">å»ºç«‹æˆ¿é–“</button>
        <button id="joinBtn" style="flex:1">åŠ å…¥æˆ¿é–“</button>
      </div>
    </div>
    <div style="margin-top:8px" class="small">å»ºç«‹æˆ¿é–“å¾Œåˆ†äº«æˆ¿è™Ÿçµ¦æœ‹å‹å³å¯å¿«é€ŸåŠ å…¥</div>
  </div>

  <div class="card" id="gameUI" style="display:none">
    <div class="row" style="justify-content:space-between">
      <div class="small roomHead" style="display:flex;align-items:center;gap:12px">
        <div class="roomIdWrap" style="display:flex;align-items:center;gap:6px">
          <div style="font-weight:700">æˆ¿è™Ÿï¼š</div>
          <div id="roomIdView" class="roomId"></div>
        </div>
        <div id="turnView" class="turnInfo">ç­‰å¾…éŠæˆ²é–‹å§‹</div>
      </div>
      <!-- å³å´ä¿ç•™ç©ºé–“ï¼ˆå¯æ”¾å…¶ä»–è³‡è¨Šï¼‰ -->
    </div>

    <div style="margin-top:8px" class="players" id="playersList"></div>

    <div style="margin-top:10px" class="board" id="board"></div>

    <!-- Dice 3D overlay (single element inside gameUI) -->
    <div id="diceOverlay" aria-hidden="true">
      <div class="scene" aria-hidden="true">
        <div class="cube rolling" id="diceCube" style="transform: rotateX(0deg) rotateY(0deg);">
          <!-- front = 1 -->
          <div class="face f1" data-face="1">
            <div class="pips">
              <div class="cell"></div><div class="cell"></div><div class="cell"></div>
              <div class="cell"></div><div class="cell"><span class="dot"></span></div><div class="cell"></div>
              <div class="cell"></div><div class="cell"></div><div class="cell"></div>
            </div>
          </div>
          <!-- back = 6 -->
          <div class="face f6" data-face="6">
            <div class="pips">
              <div class="cell"><span class="dot"></span></div><div class="cell"></div><div class="cell"><span class="dot"></span></div>
              <div class="cell"><span class="dot"></span></div><div class="cell"></div><div class="cell"><span class="dot"></span></div>
              <div class="cell"><span class="dot"></span></div><div class="cell"></div><div class="cell"><span class="dot"></span></div>
            </div>
          </div>
          <!-- right = 3 -->
          <div class="face f3" data-face="3">
            <div class="pips">
              <div class="cell"></div><div class="cell"></div><div class="cell"><span class="dot"></span></div>
              <div class="cell"></div><div class="cell"><span class="dot"></span></div><div class="cell"></div>
              <div class="cell"><span class="dot"></span></div><div class="cell"></div><div class="cell"></div>
            </div>
          </div>
          <!-- left = 4 -->
          <div class="face f4" data-face="4">
            <div class="pips">
              <div class="cell"><span class="dot"></span></div><div class="cell"></div><div class="cell"><span class="dot"></span></div>
              <div class="cell"></div><div class="cell"></div><div class="cell"></div>
              <div class="cell"><span class="dot"></span></div><div class="cell"></div><div class="cell"><span class="dot"></span></div>
            </div>
          </div>
          <!-- top = 2 -->
          <div class="face f2" data-face="2">
            <div class="pips">
              <div class="cell"></div><div class="cell"><span class="dot"></span></div><div class="cell"></div>
              <div class="cell"></div><div class="cell"></div><div class="cell"></div>
              <div class="cell"></div><div class="cell"><span class="dot"></span></div><div class="cell"></div>
            </div>
          </div>
          <!-- bottom = 5 -->
          <div class="face f5" data-face="5">
            <div class="pips">
              <div class="cell"><span class="dot"></span></div><div class="cell"></div><div class="cell"><span class="dot"></span></div>
              <div class="cell"></div><div class="cell"><span class="dot"></span></div><div class="cell"></div>
              <div class="cell"><span class="dot"></span></div><div class="cell"></div><div class="cell"><span class="dot"></span></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div style="margin-top:8px" class="log" id="log">éŠæˆ²å°šæœªé–‹å§‹</div>
    <div style="margin-top:8px" class="small">æç¤ºï¼šå»ºç«‹æˆ¿é–“å¾Œï¼Œç¬¬ä¸€å€‹åŠ å…¥çš„äººç‚ºæˆ¿ä¸»ã€‚æˆ¿ä¸»æŒ‰ <b>é–‹å§‹éŠæˆ²</b>ï¼ˆæœƒåœ¨ç©å®¶æ•¸>1æ™‚é¡¯ç¤ºï¼‰å³å¯é–‹å§‹ã€‚</div>
    <div style="margin-top:8px" id="startWrap"></div>
    <!-- å†ä¾†ä¸€å ´æŒ‰éˆ•ï¼ˆåªé¡¯ç¤ºçµ¦æˆ¿ä¸»ï¼ŒéŠæˆ²çµæŸæ™‚å‡ºç¾ï¼‰ -->
    <button id="rematchBtn" class="rematchBtn" style="display:none">å†ä¾†ä¸€å ´</button>

    <!-- pending action modalï¼ˆé¡¯ç¤ºæ ¼å­å¤§å­—èˆ‡å®ŒæˆæŒ‰éˆ•ï¼‰ -->
    <div id="pendingModal" class="pendingModal" aria-hidden="true">
      <div class="pendingBox" role="dialog" aria-modal="true">
        <div id="pendingLabel" class="pendingLabel">æ ¼å­å…§å®¹</div>
        <div class="pendingActions">
          <button id="pendingCancel" class="btn-cancel" style="display:none">å–æ¶ˆ</button>
          <button id="pendingConfirm" class="btn-confirm">å®Œæˆ</button>
        </div>
      </div>
    </div>

    <!-- è¼ªåˆ°ä½ äº† modalï¼ˆåªåœ¨è¼ªåˆ°è©²ç©å®¶ä¸”ç„¡ pending æ™‚é¡¯ç¤ºï¼‰ -->
    <div id="yourTurnModal" class="yourTurnModal" aria-hidden="true">
      <div class="yourTurnBox" role="dialog" aria-modal="true">
        <div class="yourTurnTitle">è¼ªåˆ°ä½ äº†ï¼</div>
        <button id="rollBtn">æ“²éª°å­</button>
      </div>
    </div>
  </div>

  <!-- Dice overlay element -->
  <div id="diceOverlay">
<script>
/* ============================
  Firebase config - å¡«å…¥ä½ çš„å°ˆæ¡ˆè³‡è¨Š
  åœ¨ Firebase æ§åˆ¶å° -> å°ˆæ¡ˆè¨­å®š æ‰¾åˆ° configï¼Œè²¼åˆ°ä¸‹é¢
  ç¯„ä¾‹ï¼ˆè«‹æ›¿æ›ç‚ºä½ è‡ªå·±çš„ï¼‰ï¼šï¼š
*/
const firebaseConfig = {
  apiKey: "AIzaSyBiTqclRRAs-PZZ68Usy07fKuFFUmV8_9g",
  authDomain: "online-monopoly-4dd83.firebaseapp.com",
  databaseURL: "https://online-monopoly-4dd83-default-rtdb.firebaseio.com",
  projectId: "online-monopoly-4dd83",
  storageBucket: "online-monopoly-4dd83.firebasestorage.app",
  messagingSenderId: "962099271606",
  appId: "1:962099271606:web:db60f6658ce4b6da10d317",
  measurementId: "G-W7Y7F876KM"
};
/* ============================ */

if (!firebaseConfig.apiKey || firebaseConfig.apiKey.includes("REPLACE")) {
  alert("è«‹å…ˆåˆ°ç¨‹å¼ä¸­å¡«å…¥ä½ çš„ Firebase configï¼ˆfirebaseConfigï¼‰å¾Œå†æ¸¬è©¦ã€‚");
}

// init firebase
firebase.initializeApp(firebaseConfig);
// å•Ÿå‹•åŒ¿åç™»å…¥ï¼ˆä¸€å®šè¦åœ¨ initializeApp å¾Œï¼‰
firebase.auth().signInAnonymously()
  .then(() => console.log("åŒ¿åç™»å…¥æˆåŠŸ"))
  .catch(err => console.error("åŒ¿åç™»å…¥å¤±æ•—", err));

const db = firebase.database();

/* ---------- game settings ---------- */
const BOARD_SIZE = 50; // æ”¹ç‚º 50 æ ¼
const COLS = 5;        // æ¯åˆ— 5 æ ¼ï¼ˆå›ºå®šï¼‰
const ROWS = Math.ceil(BOARD_SIZE / COLS);
const COLORS = [
  "#ef4444","#f59e0b","#10b981","#3b82f6","#8b5cf6","#ec4899",
  "#06b6d4","#84cc16","#f43f5e","#a855f7","#14b8a6","#f97316"
];

/* ---------- DOM ---------- */
const nameInput = document.getElementById("name");
const createBtn = document.getElementById("createBtn");
const joinBtn = document.getElementById("joinBtn");
const roomInfo = document.getElementById("roomInfo");
const lobby = document.getElementById("lobby");
const gameUI = document.getElementById("gameUI");
const roomIdView = document.getElementById("roomIdView");
// (myIdView removed â€” ä¸åœ¨ UI é¡¯ç¤º)
const turnView = document.getElementById("turnView");
const playersList = document.getElementById("playersList");
const boardEl = document.getElementById("board");
const rollBtn = document.getElementById("rollBtn");
// const endTurnBtn = document.getElementById("endTurnBtn"); // å·²ç§»é™¤
const logEl = document.getElementById("log");
const startWrap = document.getElementById("startWrap");
const rematchBtn = document.getElementById("rematchBtn");
const diceOverlay = document.getElementById("diceOverlay");
const diceResult = document.getElementById("diceResult");

// new: pending modal elements
const pendingModal = document.getElementById('pendingModal');
const pendingLabel = document.getElementById('pendingLabel');
const pendingConfirm = document.getElementById('pendingConfirm');
const pendingCancel = document.getElementById('pendingCancel');


// renderRoom: é¡¯ç¤º/éš±è— pending modal èˆ‡æŒ‰éˆ•ç‹€æ…‹
function renderRoom(){
  // players
  playersList.innerHTML = '';
  const players = localState.players || {};

  // Ensure turnOrder exists and is valid. If missing or empty, create from current players.
  if(!Array.isArray(localState.turnOrder) || localState.turnOrder.length === 0){
    const ids = Object.keys(players);
    if(ids.length > 0){
      // write turnOrder once (owner should ideally do this, but set optimistically)
      roomRef.child('turnOrder').set(ids);
      // return early; we'll re-render when DB updates
      return;
    }
  }

  const turnOrder = localState.turnOrder || [];
  // ensure currentTurn is a valid number
  let currentTurn = Number.isInteger(localState.currentTurn) ? localState.currentTurn : 0;
  if(turnOrder.length === 0) currentTurn = 0;
  if(currentTurn >= turnOrder.length) currentTurn = 0;

  // render player cards
  for(const pid of Object.keys(players)){
    const p = players[pid];
    const card = document.createElement('div');
    card.className = 'playerCard';
    card.style.borderLeft = `4px solid ${p.color || '#ccc'}`;
    const meMark = pid === myId ? 'ï¼ˆä½ ï¼‰' : '';
    // åƒ…é¡¯ç¤ºç©å®¶åç¨±èˆ‡æ˜¯å¦ç‚ºè‡ªå·±ï¼Œéš±è—ä½ç½®èˆ‡ id
    card.innerHTML = `<div style="font-weight:700">${p.name} ${meMark}</div>`;
    playersList.appendChild(card);
  }

  // draw board pieces
  for(let i=0;i<BOARD_SIZE;i++){
    const cell = document.getElementById('cell-'+i);
    if(cell) cell.innerHTML = ''; // clear pieces
  }
  for(const pid in players){
    const p = players[pid];
    const pos = Math.max(0, Math.min(BOARD_SIZE-1, p.pos || 0));
    const el = document.createElement('div');
    el.className = 'piece';
    // allow animation to identify which piece belongs toèª°
    el.dataset.pid = pid;
    el.style.background = p.color || '#666';
    el.textContent = p.name[0] || '?';
    el.title = p.name + (pid===turnOrder[currentTurn] ? ' (ç•¶å‰å›åˆ)' : '');
    const container = document.getElementById('cell-'+pos);
    if(container) container.appendChild(el);
  }

  // dice & turn UI
  const currentPlayerId = turnOrder.length ? turnOrder[currentTurn] : null;
  const isMyTurn = currentPlayerId === myId;
  rollBtn.disabled = !isMyTurn || !localState.started;
  // endTurnBtn.disabled = !isMyTurn || !localState.started; // å·²ç§»é™¤

  // diceDisplay.textContent = 'æ“²éª°çµæœï¼š' + (localState.lastAction?.dice ?? 'â€”');
  // æ›´æ–°å³å´çš„è¼ªåˆ°ç©å®¶é¡¯ç¤ºï¼ˆåªé¡¯ç¤ºåç¨±ï¼‰
  if(localState.started){
    turnView.textContent = `è¼ªåˆ° ${players[currentPlayerId]?.name || 'N/A'}`;
  } else {
    turnView.textContent = 'ç­‰å¾…æˆ¿ä¸»é–‹å§‹éŠæˆ²';
  }

  // start button for owner
  startWrap.innerHTML = '';
  const ownerId = localState.ownerId || Object.values(players).find(p => p.isOwner)?.id || Object.keys(players)[0];
  if(ownerId === myId && !localState.started && Object.keys(players).length > 1){
    const btn = document.createElement('button');
    btn.textContent = 'é–‹å§‹éŠæˆ²';
    btn.onclick = async ()=>{
      // ensure turnOrder initialized from current players, then start
      const snap = await roomRef.child('players').once('value');
      const ps = snap.val() || {};
      const ids = Object.keys(ps);
      if(ids.length > 0){
        await roomRef.update({ started: true, turnOrder: ids, currentTurn: 0 });
      } else {
        await roomRef.child('started').set(true);
      }
    };
    startWrap.appendChild(btn);
  }

  // é¡¯ç¤º/éš±è—ã€Œå†ä¾†ä¸€å ´ã€æŒ‰éˆ•ï¼šç•¶æˆ¿é–“æœ‰ winner ä¸”ç•¶å‰ä½¿ç”¨è€…ç‚ºæˆ¿ä¸»æ™‚é¡¯ç¤º
  if(localState.winner && ownerId === myId){
    rematchBtn.style.display = 'inline-block';
  } else {
    rematchBtn.style.display = 'none';
  }
  // if game not started, disable roll
  if(!localState.started) {
    rollBtn.disabled = true;
    // endTurnBtn.disabled = true; // å·²ç§»é™¤
  }

  // æ§åˆ¶ã€ŒéŠæˆ²å°šæœªé–‹å§‹ã€log æ–‡å­—é¡¯ç¤ºï¼šéŠæˆ²é–‹å§‹å¾Œéš±è—
  const logEl = document.getElementById('log');
  if(logEl){
    if(localState.started){
      logEl.style.display = 'none';
    } else {
      logEl.style.display = 'block';
      logEl.textContent = 'éŠæˆ²å°šæœªé–‹å§‹';
    }
  }

  // æ§åˆ¶ã€Œæç¤ºï¼šå»ºç«‹æˆ¿é–“å¾Œ...ã€small æç¤ºæ–‡å­—é¡¯ç¤ºï¼šéŠæˆ²é–‹å§‹å¾Œéš±è—
  // é¸å– gameUI å…§æœ€å¾Œä¸€å€‹ .smallï¼ˆå³æç¤ºæ–‡å­—ï¼‰
  const hints = document.querySelectorAll('#gameUI .small');
  const hintEl = hints[hints.length - 1]; // å–æœ€å¾Œä¸€å€‹ small å…ƒç´ 
  if(hintEl && hintEl.textContent.includes('æç¤ºï¼š')){
    hintEl.style.display = localState.started ? 'none' : 'block';
  }

  // disable rollBtn if pendingAction exists or not your turn
  const pending = localState.pendingAction || null;
  const isPending = !!pending;
  rollBtn.disabled = (!isMyTurn) || !localState.started || isPending;

  // show pending modal if pendingAction present
  if(pending){
    // show big label text from LABELS (use pending.cell as index)
    const idx = Number.isInteger(pending.cell) ? pending.cell : null;
    const labelText = (idx !== null && LABELS[idx]) ? LABELS[idx] : `ç¬¬ ${idx+1} æ ¼`;
    pendingLabel.textContent = labelText;
    // only the player who triggered can confirm
    if(pending.by === myId){
      pendingConfirm.style.display = 'inline-block';
      pendingConfirm.disabled = false;
      pendingCancel.style.display = 'none';
    } else {
      // others see modal but cannot confirm
      pendingConfirm.style.display = 'none';
      pendingCancel.style.display = 'none';
    }
    pendingModal.classList.add('show');
  } else {
    pendingModal.classList.remove('show');
  }

  // é¡¯ç¤ºè´å®¶è¨Šæ¯ï¼ˆåªå°è©²æˆ¿é–“çš„ç©å®¶ï¼‰
  if(localState.winner && !window._winnerShownForRoom){
    // æ¨™è¨˜å·²é¡¯ç¤ºéï¼Œé¿å…é‡è¤‡å½ˆçª—
    window._winnerShownForRoom = true;
    setTimeout(()=>{
      alert(`éŠæˆ²çµæŸï¼è´å®¶ ${localState.winner.name} å¯æŒ‡å®šæ‰€æœ‰ç©å®¶åšä»»æ„æŒ‡å®šå‹•ä½œ`);
    }, 200);
  }

  // æ§åˆ¶ã€Œè¼ªåˆ°ä½ äº†ã€modalï¼šåªåœ¨è¼ªåˆ°è©²ç©å®¶ã€éŠæˆ²å·²é–‹å§‹ã€ä¸”ç„¡ pendingActionã€ç„¡ winnerã€ä¸”å°šæœªæ“²éª°æ™‚é¡¯ç¤º
  const yourTurnModal = document.getElementById('yourTurnModal');
  if(yourTurnModal){
    // æª¢æŸ¥ lastAction æ˜¯å¦ç‚ºç•¶å‰ç©å®¶å‰›æ“²çš„éª°ï¼ˆè‹¥æ˜¯å‰‡ä¸å†é¡¯ç¤º modalï¼‰
    const lastAction = localState.lastAction || null;
    const justRolled = lastAction && lastAction.by === myId && lastAction.type === 'roll';
    
    // æª¢æŸ¥æ˜¯å¦æœ‰ diceAnimation æ­£åœ¨é€²è¡Œï¼ˆé¿å…åœ¨å‹•ç•«æœŸé–“é¡¯ç¤º modalï¼‰
    const diceAnim = localState.diceAnimation || null;
    const animating = diceAnim && (now() - diceAnim.ts < 3000); // 3ç§’å…§è¦–ç‚ºå‹•ç•«ä¸­
    
    // åªæœ‰åœ¨æ²’æœ‰å‹•ç•«ã€æ²’æœ‰æ“²ééª°ã€è¼ªåˆ°è‡ªå·±ä¸”ç„¡ pending æ™‚æ‰é¡¯ç¤º
    if(localState.started && isMyTurn && !isPending && !localState.winner && !justRolled && !animating){
      yourTurnModal.classList.add('show');
      rollBtn.disabled = false;
    } else {
      yourTurnModal.classList.remove('show');
      rollBtn.disabled = true;
    }
  }
}

/* ---------- helpers ---------- */
function uid(len=6){
  const chars = "ABCDEFGHJKMNPQRSTUVWXYZ23456789";
  let s = "";
  for(let i=0;i<len;i++) s += chars[Math.floor(Math.random()*chars.length)];
  return s;
}
function now(){ return Date.now(); }
function setLog(txt){ logEl.textContent = txt; }

/* å¯åœ¨é€™è£¡ç›´æ¥ç·¨è¼¯ 1~50 æ ¼å­çš„æ–‡å­—ï¼ˆç¨‹å¼ç«¯æ¸…å–®ï¼‰ */
const LABELS = [
  "èµ·é»",
  "åˆ†äº«æœ€å–œæ­¡çš„æ€§æ„›é«”ä½",
  "å¾èƒŒå¾ŒæŠ±ä¼´ä¾¶10ç§’",
  "è„«ä¸€ä»¶è¡£æœ",
  "åˆ†äº«è®“ä½ æ„Ÿåˆ°èˆˆå¥®çš„æ€§æ„›æƒ…æ™¯(å¯å¹»æƒ³)",
  "è·Ÿä¼´ä¾¶æ¥å»10ç§’",
  "å¹«ä½ çš„ä¼´ä¾¶è„«ä¸€ä»¶è¡£æœ",
  "æ‰“ä¼´ä¾¶çš„å±è‚¡5ä¸‹",
  "åœ¨å°æ–¹ä¼´ä¾¶çš„è€³æœµæ—èªªä¸€å¥æŒ‘é€—çš„è©±",
  "å¹«ä¸€ä½ç©å®¶è„«ä¸€ä»¶è¡£æœ",
  "èˆ”ä¼´ä¾¶çš„è€³æœµ10ç§’",
  "èˆ‡ä¼´ä¾¶åæŒ‡ç·Šæ‰£æ·±æƒ…å°æœ›10ç§’",
  "æ‰€æœ‰ç©å®¶çŒœæ‹³ï¼Œæœ€è¼¸çš„è„«ä¸€ä»¶è¡£æœ",
  "è«‹ä¸€ä½ç©å®¶å¹«ä½ è„«ä¸€ä»¶è¡£æœ",
  "è¦ªå»ä¼´ä¾¶çš„è„–å­10ç§’",
  "ååœ¨ä¼´ä¾¶æ‡·è£¡ç›´åˆ°ä½ çš„ä¸‹ä¸€å›åˆ",
  "è«‹ä¸€ä½ç©å®¶å¹«ä½ è„«ä¸€ä»¶è¡£æœ",
  "æ„›æ’«ä¼´ä¾¶æ•æ„Ÿå¸¶20ç§’",
  "å¹«ä¸€ä½ç©å®¶è„«ä¸€ä»¶è¡£æœ",
  "èˆ‡å°æ–¹ä¼´ä¾¶åæŒ‡ç·Šæ‰£æ·±æƒ…å°æœ›10ç§’",
  "èˆ”ä¼´ä¾¶å¥¶é ­10ç§’",
  "è„«å…©ä»¶è¡£æœ",
  "è·Ÿå°æ–¹ä¼´ä¾¶æ“æŠ±10ç§’é˜",
  "å¹«ä¸€ä½ç©å®¶è„«ä¸€ä»¶è¡£æœ",
  "é¸æ“‡å…©ä½ç©å®¶å„è„«ä¸€ä»¶è¡£æœ",
  "æ„›æ’«ä¼´ä¾¶ç§è™•20ç§’",
  "æ’«æ‘¸å°æ–¹ä¼´ä¾¶éç§è™•15ç§’",
  "æ‰€æœ‰ç©å®¶çŒœæ‹³ï¼Œæ‰€æœ‰è¼¸å®¶è„«ä¸€ä»¶è¡£æœ",
  "å¹«å°æ–¹ä¼´ä¾¶æŒ‰æ‘©30ç§’",
  "èˆ”å°æ–¹ä¼´ä¾¶çš„è€³æœµæˆ–è„–å­10ç§’",
  "å¹«ä¼´ä¾¶å£äº¤20ç§’",
  "é¸æ“‡ä¸€ä½ç©å®¶è„«å…©ä»¶è¡£æœ",
  "è·Ÿä¼´ä¾¶69å¼20ç§’",
  "åœ¨å°æ–¹ä¼´ä¾¶èº«ä¸Šåš3å€‹ä¼åœ°æŒºèº«",
  "å°æ–¹ä¼´ä¾¶å°ä½ è²¼èº«ç†±èˆ20ç§’",
  "ååœ¨å°æ–¹ä¼´ä¾¶æ‡·è£¡ç›´åˆ°ä½ çš„ä¸‹ä¸€å›åˆ",
  "é™¤äº†ä½ ä»¥å¤–çš„ç©å®¶å„è„«ä¸€ä»¶è¡£æœ",
  "æ’«æ‘¸å°æ–¹ä¼´ä¾¶çš„èƒ¸15ç§’",
  "æ„›æ’«å°æ–¹ä¼´ä¾¶ç§è™•20ç§’",
  "æ‰€æœ‰äººè„«ä¸€ä»¶è¡£æœ",
  "è·Ÿå°æ–¹ä¼´ä¾¶ç†±å»10ç§’",
  "å°æ–¹ä¼´ä¾¶è·¨ååœ¨ä½ èº«ä¸Šç›´åˆ°ä¸‹å€‹å‹•ä½œ",
  "èˆ”å°æ–¹ä¼´ä¾¶å¥¶é ­10ç§’",
  "è®“å…©ä½ç•°æ€§å‰å¾ŒåŒ…å¤¾ä½ 15ç§’",
  "è®“å…©ä½ç•°æ€§åŒæ™‚æ„›æ’«ä½ 20ç§’",
  "æ„›æ’«å…©ä½ç•°æ€§ç§è™•20ç§’",
  "å¹«å°æ–¹ä¼´ä¾¶å£äº¤20ç§’",
  "ä½ çš„ä¼´ä¾¶å¹«å°æ–¹å£äº¤20ç§’",
  "è·Ÿå°æ–¹ä¼´ä¾¶69å¼30ç§’",
  "çµ‚é»",
];

// ç”¨ç¨‹å¼ç«¯ LABELS æ¸…å–®ä¾†å¡«å…¥æ ¼å­æ–‡å­—ä¸­é–“çš„æ–¹å‘ç®­é ­ï¼ˆä¸æä¾›ç•«é¢ç·¨è¼¯å™¨ï¼‰
function buildBoard(){
  boardEl.innerHTML = "";
  // ä¿å­˜è¦–è¦ºåº§æ¨™ (row/col) å°æ‡‰åˆ°é‚è¼¯ index
  const posMap = new Array(BOARD_SIZE);
  // å…ˆä»¥è¦–è¦ºæ ¼é †åºå»ºç«‹ cell DOMï¼Œä¸¦è¨˜éŒ„æ¯å€‹ logicalIdx çš„è¦–è¦º row/col
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const gridIndex = r*COLS + c;
      if(gridIndex >= BOARD_SIZE) break;
      const logicalIdx = (r % 2 === 0) ? (r*COLS + c) : (r*COLS + (COLS - 1 - c));
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.idx = logicalIdx;
      const label = LABELS[logicalIdx] || "";
      // å…§å« pieces èˆ‡ cellLabelï¼Œä¸¦é ç•™ç®­é ­ä½ç½®
      cell.innerHTML = `<div class="pieces" id="cell-${logicalIdx}"></div><div class="cellLabel">${label}</div><div class="dirArrow dir-none" id="arrow-${logicalIdx}">â€º</div>`;
      boardEl.appendChild(cell);
      posMap[logicalIdx] = { row: r, col: c };
    }
  }

  // è¨ˆç®—æ¯å€‹æ ¼å­çš„ç®­é ­æ–¹å‘ï¼ˆæ ¹æ“šä¸‹ä¸€å€‹ logical index çš„è¦–è¦ºä½ç½®ï¼‰
  for(let i=0;i<BOARD_SIZE;i++){
    const arrowEl = document.getElementById(`arrow-${i}`);
    if(!arrowEl) continue;
    if(i >= BOARD_SIZE - 1){
      // æœ€å¾Œä¸€æ ¼ä¸é¡¯ç¤ºç®­é ­
      arrowEl.className = 'dirArrow dir-none';
      continue;
    }
    const cur = posMap[i];
    const nxt = posMap[i+1];
    if(!cur || !nxt){
      arrowEl.className = 'dirArrow dir-none';
      continue;
    }
    // æ¯”è¼ƒè¦–è¦ºåº§æ¨™ï¼Œæ±ºå®šæ–¹å‘
    if(nxt.row === cur.row && nxt.col === cur.col + 1){
      arrowEl.className = 'dirArrow dir-right';
    }else if(nxt.row === cur.row && nxt.col === cur.col - 1){
      arrowEl.className = 'dirArrow dir-left';
    }else if(nxt.row === cur.row + 1 && nxt.col === cur.col){
      arrowEl.className = 'dirArrow dir-down';
    }else if(nxt.row === cur.row - 1 && nxt.col === cur.col){
      arrowEl.className = 'dirArrow dir-up';
    }else{
      arrowEl.className = 'dirArrow dir-none';
    }
  }

  // ensure labels fit after board built
  adjustCellLabels();
}

// æ–°å¢ï¼šç”¢ç”Ÿ 4 ä½æ•¸å­—æˆ¿è™Ÿ
function generateRoomId(){
  return String(Math.floor(1000 + Math.random()*9000)); // 1000-9999
}

/* ---------- room functions ---------- */
createBtn.addEventListener("click", async ()=>{
  myName = (nameInput.value || "ç©å®¶").slice(0,16);
  myId = uid(6);
  // æ”¹ç‚ºå››ä½æ•¸å­—æˆ¿è™Ÿ
  const newRoom = generateRoomId();
  roomId = newRoom;
  roomRef = db.ref('rooms/'+roomId);
  // initialize room state
  const init = {
    createdAt: now(),
    players: {},
    turnOrder: [],
    currentTurn: 0,
    started: false,
    boardSize: BOARD_SIZE,
    lastAction: null
  };
  await roomRef.set(init);
  joinRoom(roomId, myId, myName, true);
});

joinBtn.addEventListener("click", async ()=>{
  myName = (nameInput.value || "ç©å®¶").slice(0,16);
  myId = uid(6);
  const ask = prompt("è¼¸å…¥æˆ¿è™Ÿæˆ–é€£çµ (æˆ¿è™Ÿç¯„ä¾‹: 1234)");
  if(!ask) return;
  // extract 4-digit room id
  const m = ask.match(/\d{4}/);
  if(!m) return alert("æ‰¾ä¸åˆ°æœ‰æ•ˆæˆ¿è™Ÿï¼ˆéœ€ç‚º 4 ä½æ•¸å­—ï¼‰ï¼Œè«‹é‡æ–°è¼¸å…¥ã€‚");
  roomId = m[0];
  roomRef = db.ref('rooms/'+roomId);

  // æª¢æŸ¥è©²æˆ¿é–“æ˜¯å¦å­˜åœ¨ä¸”å·²æœ‰ç©å®¶ï¼ˆç¦æ­¢åŠ å…¥ä¸å­˜åœ¨æˆ–ç©ºçš„æˆ¿é–“ï¼‰
  const snap = await roomRef.once('value');
  const data = snap.val();
  const hasPlayers = data && data.players && Object.keys(data.players).length > 0;
  if(!snap.exists() || !hasPlayers){
    return alert("æˆ¿é–“ä¸å­˜åœ¨æˆ–å°šç„¡ç©å®¶ï¼Œç„¡æ³•åŠ å…¥ã€‚è«‹è«‹æ±‚æˆ¿ä¸»å»ºç«‹æˆ¿é–“å¾Œå†åŠ å…¥ï¼Œæˆ–ç›´æ¥æŒ‰ã€Œå»ºç«‹æˆ¿é–“ã€ã€‚");
  }

  joinRoom(roomId, myId, myName, false);
});

// join logic (isOwner flag if creator)
async function joinRoom(rid, playerId, playerName, isOwner){
  roomRef = db.ref('rooms/'+rid);
  
  // åˆå§‹åŒ–è´å®¶è¨Šæ¯é¡¯ç¤ºæ¨™è¨˜ï¼ˆå…¨åŸŸè®Šæ•¸ï¼Œè·¨ renderRoom ä¿ç•™ï¼‰
  window._winnerShownForRoom = false;
  
  // è®€å–ç›®å‰æˆ¿é–“å…§æ‰€æœ‰ç©å®¶å·²ä½¿ç”¨çš„é¡è‰²
  const snap = await roomRef.child('players').once('value');
  const existingPlayers = snap.val() || {};
  const usedColors = Object.values(existingPlayers).map(p => p.color).filter(Boolean);
  
  // å¾ COLORS ä¸­æŒ‘é¸ç¬¬ä¸€å€‹æœªè¢«ä½¿ç”¨çš„é¡è‰²
  let assignedColor = COLORS.find(c => !usedColors.includes(c));
  // å¦‚æœæ‰€æœ‰é¡è‰²éƒ½è¢«ç”¨å®Œï¼ˆç©å®¶æ•¸è¶…éé¡è‰²æ•¸ï¼‰ï¼Œå‰‡éš¨æ©Ÿåˆ†é…æˆ–ç”¨é è¨­è‰²
  if(!assignedColor){
    assignedColor = COLORS[Math.floor(Math.random() * COLORS.length)];
  }
  
  // add player to players list
  const playerRef = roomRef.child('players').child(playerId);
  const playerObj = {
    id: playerId, 
    name: playerName, 
    pos: 0, 
    color: assignedColor,  // ä½¿ç”¨æŒ‘é¸çš„å”¯ä¸€é¡è‰²
    joinedAt: now(), 
    isOwner: !!isOwner
  };
  await playerRef.set(playerObj);
  // ensure presence removal on disconnect
  playerRef.onDisconnect().remove();

  // if this joiner is owner, ensure room.ownerId is set (helps race conditions)
  if(isOwner){
    await roomRef.child('ownerId').set(playerId);
  }

  // listen room changes
  roomRef.on('value', snapshot=>{
    localState = snapshot.val();
    if(!localState) {
      alert("æˆ¿é–“ä¸å­˜åœ¨æˆ–å·²åˆªé™¤ã€‚");
      cleanup();
      return;
    }
    // é‡ç½®è´å®¶è¨Šæ¯æ¨™è¨˜ï¼ˆç•¶ winner å¾æœ‰è®Šç„¡æ™‚ï¼Œä¾‹å¦‚å†ä¾†ä¸€å ´ï¼‰
    if(!localState.winner && window._winnerShownForRoom){
      window._winnerShownForRoom = false;
    }
    renderRoom();
  });

  // ç›£è½ diceAnimation ç¯€é»ï¼Œç•¶æœ‰æ–°å‹•ç•«æ™‚æ’­æ”¾çµ¦æ‰€æœ‰äººçœ‹
  let lastDiceAnimationTs = 0;
  roomRef.child('diceAnimation').on('value', snapshot=>{
    const anim = snapshot.val();
    if(!anim) return;
    
    // é¿å…é‡è¤‡æ’­æ”¾ï¼ˆæª¢æŸ¥æ™‚é–“æˆ³ï¼‰
    if(anim.ts && anim.ts > lastDiceAnimationTs){
      lastDiceAnimationTs = anim.ts;
      
      // å¦‚æœä¸æ˜¯è‡ªå·±æ“²çš„éª°å­ï¼Œå°±æ’­æ”¾å‹•ç•«ï¼ˆè‡ªå·±çš„å·²åœ¨ rollBtn ä¸­æ’­æ”¾ï¼‰
      if(anim.by !== myId){
        animateDiceAndShow(anim.face);
      }
    }
  });

  // update UI
  lobby.style.display = 'none';
  gameUI.style.display = 'block';
  roomIdView.textContent = rid;
  // share link
  const joinLink = location.href.split('#')[0] + '#room=' + rid;
  roomInfo.textContent = 'åˆ†äº«æ­¤é€£çµåŠ å…¥ï¼š' + joinLink;
  // auto-handle if url had room id (support opening via link)
  if(location.hash.includes('room=')){
    // nothing extra
  }
}

/* ---------- gameplay actions ---------- */
// helper: animate dice and show final face (3D cube)
function animateDiceAndShow(face){
  return new Promise(resolve=>{
    const overlay = document.getElementById('diceOverlay');
    const cube = document.getElementById('diceCube');
    if(!overlay || !cube){
      setTimeout(()=>resolve(face), 800);
      return;
    }

    // mapping dice face -> cube transform (bring that face to front)
    const faceTransforms = {
      1: 'rotateX(0deg) rotateY(0deg)',        // front
      2: 'rotateX(-90deg) rotateY(0deg)',      // top -> bring front
      3: 'rotateX(0deg) rotateY(-90deg)',      // right
      4: 'rotateX(0deg) rotateY(90deg)',       // left
      5: 'rotateX(90deg) rotateY(0deg)',       // bottom
      6: 'rotateX(0deg) rotateY(180deg)'       // back
    };

    // show overlay, start rolling animation
    overlay.classList.add('show');
    cube.classList.add('rolling');

    // small visual jitter before final settle
    const rollingMs = 1200;
    setTimeout(()=>{
      // stop rolling and set final transform
      cube.classList.remove('rolling');
      cube.style.transform = faceTransforms[face] || faceTransforms[1];
      // ensure transition finishes then hide overlay
      const settleMs = 1500;
      setTimeout(()=>{
        overlay.classList.remove('show');
        // reset transform slightly after hide so next roll starts from neutral
        setTimeout(()=>{ cube.style.transform = 'rotateX(0deg) rotateY(0deg)'; }, 200);
        resolve(face);
      }, settleMs);
    }, rollingMs);
  });
}

// æ›¿æ›åŸæœ¬çš„ rollBtn äº‹ä»¶è™•ç†å™¨ï¼šå…ˆé©—è­‰å›åˆ -> ç«‹å³éš±è— modal -> æ’¥æ”¾å‹•ç•« -> å¯« DB
rollBtn.addEventListener('click', async ()=>{
  if(!localState) return;

  // å–å¾—ä¼ºæœå™¨ä¸Šæœ€æ–°çš„ turnOrderï¼ˆé¿å…æœ¬åœ° staleï¼‰
  const orderSnap = await roomRef.child('turnOrder').once('value');
  const serverOrder = orderSnap.val() || [];
  const expectedCurrent = Number.isInteger(localState.currentTurn) ? localState.currentTurn : 0;
  const currentPlayerId = serverOrder[expectedCurrent] || serverOrder[0] || null;
  if(currentPlayerId !== myId) return alert('ç¾åœ¨ä¸æ˜¯ä½ çš„å›åˆ');

  // ç«‹å³éš±è—ã€Œè¼ªåˆ°ä½ äº†ã€modalï¼Œè®“éª°å­å‹•ç•«å¯è¦‹
  const yourTurnModal = document.getElementById('yourTurnModal');
  if(yourTurnModal){
    yourTurnModal.classList.remove('show');
  }

  // disable UI immediately to prevent multiple clicks
  rollBtn.disabled = true;

  // é å…ˆç”¢ç”Ÿé»æ•¸
  const dice = Math.floor(Math.random()*6)+1;
  
  try{
    // å¯«å…¥ diceAnimation ç¯€é»åˆ° DBï¼Œè§¸ç™¼æ‰€æœ‰å®¢æˆ¶ç«¯æ’­æ”¾å‹•ç•«
    await roomRef.child('diceAnimation').set({
      face: dice,
      by: myId,
      ts: now()
    });

    // æœ¬åœ°ä¹Ÿæ’­æ”¾å‹•ç•«ï¼ˆé¿å…å»¶é²ï¼‰
    await animateDiceAndShow(dice);

    // å¯« lastAction (so others see the dice result)
    const action = {type:'roll', by: myId, dice, ts: now()};
    await roomRef.child('lastAction').set(action);

    // read current stored position (server) as "from"
    const playerPath = 'players/' + myId;
    const snap = await roomRef.child(playerPath).once('value');
    const p = snap.val();
    const oldPos = p?.pos || 0;
    const targetPos = Math.min(BOARD_SIZE-1, oldPos + dice);

    // perform local step-by-step animation then persist each step (animatePlayerSteps will set pendingAction at the end)
    await animatePlayerSteps(myId, oldPos, dice);

    // If reached final cell, set winner (no automatic turn advance here)
    if(targetPos >= BOARD_SIZE-1){
      await roomRef.child('winner').set({id: myId, name: p.name, at: now()});
      return;
    }

    // NOTE: ä¸åœ¨æ­¤è‡ªå‹•æ¨é€² currentTurnï¼Œæ”¹ç”± pendingConfirmï¼ˆç©å®¶æŒ‰å®Œæˆï¼‰ä¾†æ¨é€²
  }catch(err){
    console.error('æ“²éª°è™•ç†å¤±æ•—', err);
    alert('æ“²éª°å¤±æ•—ï¼š' + (err.message || err));
  }finally{
    // UI will remain disabled while pendingAction exists; ensure button state consistent on errors
    rollBtn.disabled = !localState?.started;
  }
});

// æˆ¿ä¸»æŒ‰ä¸‹ã€Œå†ä¾†ä¸€å ´ã€ï¼šé‡ç½®ç©å®¶ä½ç½®ã€turnOrderã€currentTurnã€lastActionã€winnerï¼Œä¸¦å•Ÿå‹•éŠæˆ²
rematchBtn.addEventListener('click', async ()=>{
  if(!roomRef || !localState) return;
  const ownerId = localState.ownerId || Object.values(localState.players || {}).find(p => p.isOwner)?.id || Object.keys(localState.players || {})[0];
  if(ownerId !== myId) return alert('åªæœ‰æˆ¿ä¸»å¯ä»¥é‡æ–°é–‹å§‹éŠæˆ²');

  // è®€å–ç›®å‰ç©å®¶åˆ—è¡¨
  const snap = await roomRef.child('players').once('value');
  const players = snap.val() || {};
  const ids = Object.keys(players);

  // å»ºç«‹è¦å¯«å…¥ DB çš„æ›´æ–°ç‰©ä»¶
  const updates = {};
  ids.forEach(pid=>{
    updates[`players/${pid}/pos`] = 0;
  });
  updates['lastAction'] = null;
  updates['winner'] = null;
  updates['started'] = true;
  updates['turnOrder'] = ids;
  updates['currentTurn'] = 0;

  try{
    await roomRef.update(updates);
  }catch(e){
    alert('é‡æ–°é–‹å§‹å¤±æ•—ï¼š' + e.message);
  }
});

// animate one piece step (fromIdx -> toIdx)
// returns a Promise that resolves after duration + pause
function animatePieceStep(pid, fromIdx, toIdx, duration = 300, pause = 100){
  return new Promise(resolve=>{
    try{
      const fromCell = document.getElementById('cell-'+fromIdx);
      const toCell = document.getElementById('cell-'+toIdx);
      if(!fromCell || !toCell){
        return setTimeout(resolve, duration + pause);
      }

      // try to find actual element in fromCell for that pid
      let srcEl = fromCell.querySelector(`.piece[data-pid="${pid}"]`);
      // if not found, synthesize based on localState players
      if(!srcEl){
        const p = (localState && localState.players && localState.players[pid]) || null;
        srcEl = document.createElement('div');
        srcEl.className = 'piece';
        srcEl.textContent = p ? (p.name[0]||'?') : '?';
        srcEl.style.background = p ? (p.color||'#666') : '#666';
        // note: not appended to DOM; used only as template for clone
      }

      const fromRect = srcEl.getBoundingClientRect && srcEl.getBoundingClientRect().width ? srcEl.getBoundingClientRect() : fromCell.getBoundingClientRect();
      const toRect = toCell.getBoundingClientRect();
      const dx = (toRect.left + toRect.width/2) - (fromRect.left + fromRect.width/2);
      const dy = (toRect.top + toRect.height/2) - (fromRect.top + fromRect.height/2);

      // create fixed-position clone
      const clone = srcEl.cloneNode(true);
      clone.style.position = 'fixed';
      clone.style.left = (fromRect.left) + 'px';
      clone.style.top = (fromRect.top) + 'px';
      clone.style.width = (fromRect.width) + 'px';
      clone.style.height = (fromRect.height) + 'px';
      clone.style.margin = '0';
      clone.style.zIndex = 9999;
      clone.style.transition = `transform ${duration}ms linear, opacity 80ms linear`;
      clone.style.transform = 'translate(0px,0px)';
      clone.style.pointerEvents = 'none';
      document.body.appendChild(clone);

      // move next frame
      requestAnimationFrame(()=>{
        clone.style.transform = `translate(${Math.round(dx)}px, ${Math.round(dy)}px)`;
      });

      // after move complete, remove clone and resolve after pause
      setTimeout(()=>{
        clone.remove();
        setTimeout(resolve, pause);
      }, duration + 10);
    }catch(e){
      console.warn('animatePieceStep error', e);
      setTimeout(resolve, duration + pause);
    }
  });
}

// animate sequential steps for a player (from -> from+steps)
// ç¾åœ¨æœƒåœ¨æ¯ä¸€æ­¥å‹•ç•«å¾Œç«‹åˆ»å¯«å…¥ DBï¼Œè®“å…¶ä»–ç©å®¶çœ‹åˆ°é€æ­¥ç§»å‹•
async function animatePlayerSteps(pid, fromIdx, steps){
  if(steps <= 0) return;
  let cur = fromIdx;
  for(let i=1;i<=steps;i++){
    const next = Math.min(BOARD_SIZE-1, fromIdx + i);
    // animate one cell move (0.3s) then pause 0.1s
    await animatePieceStep(pid, cur, next, 300, 100);

    // åŒæ­¥æ­¤ä¸€æ­¥åˆ° DBï¼Œè®“å…¶ä»–ç©å®¶çœ‹åˆ°é€æ­¥æ›´æ–°
    try{
      await roomRef.child(`players/${pid}/pos`).set(next);
    }catch(e){
      console.warn('failed to write step pos', e);
    }

    cur = next;
  }

  // after finishing movement, create pendingAction so the player must confirm
  try{
    await roomRef.child('pendingAction').set({ by: pid, cell: cur, ts: now() });
  }catch(e){
    console.warn('failed to set pendingAction', e);
  }
}

/* ---------- room cleanup ---------- */
function cleanup(){
  // turn off listeners
  if(roomRef) roomRef.off();
  roomRef = null;
  localState = null;
  roomId = null;
  myId = null;
  lobby.style.display = 'block';
  gameUI.style.display = 'none';
  roomInfo.textContent = 'å°šæœªåŠ å…¥æˆ¿é–“';
}

/* ---------- initial board build ---------- */
buildBoard();

/* ========== é–‹ç™¼æ¸¬è©¦æ¨¡å¼ï¼šå¿«é€Ÿè·³åˆ°çµ‚é»é™„è¿‘ ==========
// åœ¨æ­£å¼ä¸Šç·šå‰è«‹åˆªé™¤æ­¤å€å¡Š
const testModeBtn = document.createElement('button');
testModeBtn.textContent = 'ğŸ§ª æ¸¬è©¦ï¼šè·³åˆ°çµ‚é»å‰';
testModeBtn.style.cssText = 'position:fixed;top:10px;right:10px;z-index:999;background:#ff6b6b;color:white;padding:8px 12px;border-radius:8px;font-size:12px;font-weight:700;border:2px solid #fff;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
testModeBtn.onclick = async ()=>{
  if(!roomRef || !myId || !localState) return alert('è«‹å…ˆåŠ å…¥æˆ¿é–“');
  
  // ç›´æ¥å°‡ç•¶å‰ç©å®¶è¨­åˆ°ç¬¬ 47 æ ¼ï¼ˆè·é›¢çµ‚é» 2 æ ¼ï¼Œæ–¹ä¾¿æ¸¬è©¦ï¼‰
  try{
    await roomRef.child(`players/${myId}/pos`).set(47);
    alert('å·²è·³åˆ°ç¬¬ 47 æ ¼ï¼ˆè·é›¢çµ‚é» 2 æ ¼ï¼‰ï¼Œå¯ä»¥é–‹å§‹æ¸¬è©¦çµ‚é»è¨Šæ¯');
  }catch(e){
    alert('è·³è½‰å¤±æ•—ï¼š' + e.message);
  }
};
document.body.appendChild(testModeBtn);
 ========== æ¸¬è©¦æ¨¡å¼çµæŸ ========== */

/* ---------- auto-join if URL contains room=... ---------- */
window.addEventListener('load', async ()=>{
  const m = location.hash.match(/room=(\d{4})/);
  if(m){
    // auto-prompt for name then join
    const suggestedName = prompt("è¼¸å…¥ä½ çš„åå­—ï¼ˆæœƒé¡¯ç¤ºçµ¦æˆ¿å…§ç©å®¶ï¼‰", "ç©å®¶");
    nameInput.value = suggestedName || "ç©å®¶";

    // è§£ææ¬²åŠ å…¥çš„æˆ¿è™Ÿä¸¦å…ˆæª¢æŸ¥ DB æ˜¯å¦å…è¨±åŠ å…¥
    const room = m[1];
    if(room){
      myName = (nameInput.value || "ç©å®¶").slice(0,16);
      myId = uid(6);
      roomId = room;
      roomRef = db.ref('rooms/'+roomId);

      const snap = await roomRef.once('value');
      const data = snap.val();
      const hasPlayers = data && data.players && Object.keys(data.players).length > 0;
      if(!snap.exists() || !hasPlayers){
        alert("ç¶²å€æˆ–æˆ¿è™ŸæŒ‡å‘çš„æˆ¿é–“ä¸å­˜åœ¨æˆ–å°šç„¡ç©å®¶ï¼Œç„¡æ³•è‡ªå‹•åŠ å…¥ã€‚è«‹å…ˆç”±æˆ¿ä¸»å»ºç«‹æˆ¿é–“å†åˆ†äº«ã€‚");
        return;
      }

      joinRoom(roomId, myId, myName, false);
    }
  }
});


// pending confirm handler: only the landing player can confirm, then advance turn
pendingConfirm.addEventListener('click', async ()=>{
  if(!roomRef || !localState) return;
  const pending = localState.pendingAction;
  if(!pending) return;
  if(pending.by !== myId) return alert('åªæœ‰è½åœ¨è©²æ ¼çš„ç©å®¶å¯ä»¥æŒ‰å®Œæˆã€‚');

  // clear pendingAction first
  try{
    await roomRef.child('pendingAction').set(null);
  }catch(e){
    console.warn('failed to clear pendingAction', e);
  }

  // if game already has winner, do not advance turn (also skip showing alert again)
  if(localState.winner){
    return;
  }

  // advance currentTurn atomically
  try{
    const latestOrderSnap = await roomRef.child('turnOrder').once('value');
    const latestOrder = latestOrderSnap.val() || [];
    const total = latestOrder.length || 0;
    if(total > 0){
      await roomRef.child('currentTurn').transaction(curr=>{
        const nowCurr = Number.isInteger(curr) ? curr : 0;
        return (nowCurr + 1) % total;
      });
    }
  }catch(e){
    console.warn('failed to advance turn', e);
  }
});

/* ------- auto-fit labels helper (paste here) ------- */
function debounce(fn, wait=120){
  let t;
  return (...args)=>{ clearTimeout(t); t = setTimeout(()=>fn(...args), wait); };
}

function fitLabelToBox(labelEl, maxFont = 14, minFont = 8){
  if(!labelEl) return;
  const cell = labelEl.closest('.cell');
  if(!cell) return;

  // reset to baseline
  let font = maxFont;
  labelEl.style.fontSize = font + 'px';
  labelEl.style.lineHeight = '1.05';
  labelEl.style.whiteSpace = 'normal';
  labelEl.style.display = 'block';
  labelEl.style.overflow = 'hidden';

  // compute available area inside cell (account padding/border)
  const cs = getComputedStyle(cell);
  const padX = (parseFloat(cs.paddingLeft) || 0) + (parseFloat(cs.paddingRight) || 0);
  const padY = (parseFloat(cs.paddingTop) || 0) + (parseFloat(cs.paddingBottom) || 0);
  const availW = Math.max(4, cell.clientWidth - padX);
  const availH = Math.max(4, cell.clientHeight - padY);

  // shrink until fits or reach minFont
  let iter = 0;
  while(iter < 30){
    // measurements after applied font
    const overflowX = labelEl.scrollWidth > availW + 1;
    const overflowY = labelEl.scrollHeight > availH + 1;
    if(!overflowX && !overflowY) break;
    font--;
    if(font < minFont){ font = minFont; labelEl.style.fontSize = font + 'px'; break; }
    labelEl.style.fontSize = font + 'px';
    iter++;
  }
  labelEl.style.fontSize = font + 'px';
}

function adjustCellLabels(){
  // schedule on next frame so layout has settled
  requestAnimationFrame(()=>{
    const labels = document.querySelectorAll('.cellLabel');
    
    // åˆ†é›¢èµ·é»/çµ‚é»èˆ‡ä¸€èˆ¬æ ¼å­
    const normalLabels = [];
    const specialLabels = []; // èµ·é» (data-idx=0) èˆ‡çµ‚é» (data-idx=49)
    
    labels.forEach(l => {
      const cell = l.closest('.cell');
      if(!cell) return;
      const idx = cell.dataset.idx;
      // æ’é™¤ç¬¬ä¸€æ ¼ (0) èˆ‡æœ€å¾Œä¸€æ ¼ (49)
      if(idx === '0' || idx === '49'){
        specialLabels.push(l);
      } else {
        normalLabels.push(l);
      }
    });

    // å¦‚æœæ²’æœ‰ä¸€èˆ¬æ ¼å­ï¼Œç›´æ¥è¿”å›
    if(normalLabels.length === 0) return;

    // å…ˆå°æ¯å€‹ä¸€èˆ¬æ ¼å­è©¦ç®—å‡ºå„è‡ªçš„æœ€å°å­—é«”ï¼ˆä¸å¯¦éš›å¥—ç”¨ï¼‰
    let globalMinFont = 14; // èµ·å§‹æœ€å¤§å­—é«”
    const maxFont = 14;
    const minFont = 8;

    for(const labelEl of normalLabels){
      const cell = labelEl.closest('.cell');
      if(!cell) continue;

      // æš«æ™‚å¥—ç”¨ maxFont ä¸¦è¨ˆç®—å¯ç”¨ç©ºé–“
      let font = maxFont;
      labelEl.style.fontSize = font + 'px';
      labelEl.style.lineHeight = '1.05';
      labelEl.style.whiteSpace = 'normal';
      labelEl.style.display = 'block';
      labelEl.style.overflow = 'hidden';

      const cs = getComputedStyle(cell);
      const padX = (parseFloat(cs.paddingLeft) || 0) + (parseFloat(cs.paddingRight) || 0);
      const padY = (parseFloat(cs.paddingTop) || 0) + (parseFloat(cs.paddingBottom) || 0);
      const availW = Math.max(4, cell.clientWidth - padX);
      const availH = Math.max(4, cell.clientHeight - padY);

      // ç¸®å°ç›´åˆ°é©åˆ
      let iter = 0;
      while(iter < 30){
        const overflowX = labelEl.scrollWidth > availW + 1;
        const overflowY = labelEl.scrollHeight > availH + 1;
        if(!overflowX && !overflowY) break;
        font--;
        if(font < minFont){ font = minFont; break; }
        labelEl.style.fontSize = font + 'px';
        iter++;
      }

      // è¨˜éŒ„æ­¤æ ¼å­æ‰€éœ€çš„æœ€å°å­—é«”
      if(font < globalMinFont) globalMinFont = font;
    }

    // çµ±ä¸€å¥—ç”¨ globalMinFont åˆ°æ‰€æœ‰ä¸€èˆ¬æ ¼å­
    normalLabels.forEach(l => {
      l.style.fontSize = globalMinFont + 'px';
      l.style.lineHeight = '1.05';
      l.style.whiteSpace = 'normal';
      l.style.display = 'block';
      l.style.overflow = 'hidden';
    });

    // èµ·é»èˆ‡çµ‚é»ä¿æŒåŸå§‹æ¨£å¼æˆ–å–®ç¨è™•ç†ï¼ˆé€™è£¡ä¸æ”¹è®Šå­—é«”ï¼‰
    specialLabels.forEach(l => {
      // å¯é¸ï¼šè¨­å®šå›ºå®šå­—é«”æˆ–ä¿æŒé è¨­
      // l.style.fontSize = '14px'; // è‹¥è¦å›ºå®šå¤§å°
    });
  });
}

// observe board mutations to refit labels when content or layout changes
(function observeBoard(){
  try{
    const board = document.getElementById('board');
    if(!board || !window.MutationObserver) return;
    const obs = new MutationObserver(debounce(()=> adjustCellLabels(), 80));
    obs.observe(board, { childList:true, subtree:true, characterData:true, attributes:true });
  }catch(e){
    console.warn('observeBoard failed', e);
  }
})();

// re-fit on resize (debounced)
window.addEventListener('resize', debounce(()=> adjustCellLabels(), 120));

// ensure initial fit after page load and after initial buildBoard call
window.addEventListener('load', ()=> setTimeout(adjustCellLabels, 80));
// also call once now in case script runs after DOM ready
setTimeout(adjustCellLabels, 120);
// ------- end auto-fit labels helper -------
</script>
</body>
</html>
